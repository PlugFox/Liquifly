## Цели

Проект симуляции движения вязкой жидкости состоящей из множества пузырьков.

Визуализация симуляции жидкости с пузырьками на Flutter с использованием Rust для просчета физики движения пузырьков.
Взаимодействие Flutter и Rust через FFI для императивных вызовов со стороны Flutter и переодическая отправка данных из Rust во Flutter через SendPort.

Количество пузырьков и их размер настраивается.
Размер экрана может меняться, симуляция должна адаптироваться к новым размерам.
Пузырьки взаимодействуют между собой, на них действует гравитация, стенки мира и передаваемые внешние импульсы (например, нажатия на экран).

Цель проекта максимально производительная логика и отображение большого количества сущностей (пузырьков) на экране с плавной анимацией.
Достоверность физики вторична, важна производительность и плавность.

При запуске симуляции мира создается отдельный тред в котором буфер положения точек (пузырьков) мутирует с заданой частотой (например 60 раз в секунду). После каждого обновления буфер отправляется во Flutter через SendPort для отрисовки.

Возможно тут будет полезна структура QuadTree или даже лучше Spatial Hash Grid для оптимизации поиска соседних пузырьков при расчете взаимодействия между ними.

Разделение на Broad phase и Narrow phase для оптимизации столкновений между пузырьками.

Столкновения со стенками: упругая/частично упругая реакция плюс лёгкое трение.

Обновление скоростей и интеграция позиций — параллельно по чанкам (rayon).

Используем mutex/atomic операции или lock-free структуры (crossbeam) для избежания гонок при параллельном доступе к данным.

Построение сетки — параллельно: сначала считаем хэш-клетку для каждой точки, потом radix-like сортировка/бакетизация.

Разрешение коллизий — по клеткам, клетки распределяем по потокам. Для избежать гонок на одну частицу применяем либо:

- read old, write to temp, затем редукция
- cell-coloring (чередуем независимые клетки).

Double buffering буфера позиций точек между Rust и Flutter для избежания гонок.
Rust пишет в один буфер, пока он не готов - Flutter читает из другого буфера.

Сообщения в изолят Dart через Dart_PostCObject_DL как int о том что новый буфер готов.

Flutter явно pull'ит новый буфер Float32List из Rust на каждый кадр (60/120 Гц) если был получен сигнал что новый буфер готов.

Flutter выводит пузырьки на экран используя drawRawPoints с использованием Canvas.

При деградации производительности (низкий FPS) - уменьшать количество пузырьков или частоту тиков симуляции.

Интерфейс должен обладать следующими методами:

```dart
// Инициализация DL API, вызывается один раз при загрузке библиотеки
void init_dl_api(void* init_data);

// Создать мир / симуляцию
// Передать SendPort для колбэков уведомления о готовности нового буфера
// Возвращает id созданного мира
int create(int sendPort);

// Получить снимок текущих позиций точек пузырьков
// Возвращает Float32List с позициями точек [x1, y1, x2, y2, ...]
Float32List snapshot(int id);

// Реконфигурировать мир
// Установить размеры мира, гравитацию, радиус и количество точек
void config(
    // Идентификатор мира
    int id,
    // Частота тиков / симуляции в герцах
    // 24-240 Гц
    // Если меньше 1 - игнорировать и не менять
    int tick_hz,
    // Количество CPU ядер для использования
    // Если 0 - использовать все доступные, автоопределение
    int cpu,
    // Размеры мира - ширина
    // Если меняется, симуляция должна адаптироваться, выталкивая пузырьки внутрь
    // Если меньше 1 - игнорировать и не менять
    int worldWidth,
    // Размеры мира - высота
    // Если меняется, симуляция должна адаптироваться, выталкивая пузырьки внутрь
    // Если меньше 1 - игнорировать и не менять
    int worldHeight,
    // Коэффициент упругости при столкновениях со стенками и между пузырьками
    // 0.0 - полностью неупруго, 1.0 - полностью упруго
    // Если за границей - игнорировать и не менять
    double restitution,
    // Коэффициент вязкости жидкости
    // 0.0 - нет вязкости, 1.0 - высокая вязкость
    // Если за границей - игнорировать и не менять
    double damping,
    // Гравитация по X
    // Положительное значение тянет вправо
    // Например -100 до 100
    int gravityX,
    // Гравитация по Y
    // Положительное значение тянет вниз
    // Например -100 до 100
    int gravityY,
    // Радиус пузырьков
    // В пикселях, например 1-100
    // Если меньше 1 - игнорировать и не менять
    // Если слишком большой - ограничить по размеру мира
    // Например не больше min(width, height) / 2
    int radius,
    // Количество пузырьков
    // Например 0-10000
    // Если меньше 0 - игнорировать и не менять
    // Если 0 - удалить все пузырьки
    // Если слишком много - ограничить разумным максимумом
    int count
);

// Событие импульса/пуша: центр и сила
void impulse(
    // Идентификатор мира
    int id,
    // Координаты центра импульса - X
    double x,
    // Координаты центра импульса - Y
    double y,
    // Сила импульса
    double strength,
    // Радиус воздействия
    double radius
);

// Приостановить мир / симуляцию
// Просто перестать считать, например когда окно не в фокусе
void pause(int id);

// Запустить или возобновить физику мира / симуляции
void resume(int id);

// Получить статус мира / симуляции
// Будет раз в секунду вызываться из Flutter для мониторинга
// Возвращает:
// 0 - уничтожен
// 1 - работает
// 2 - приостановлен
int status(int id);

// Получить статистику производительности
// Будет раз в секунду вызываться из Flutter для мониторинга
// - FPS симуляции
// - Время расчета коллизий
// - Количество активных коллизий
// - Использование памяти
PerformanceStats stats(int id);

// Уничтожить мир и высвободить ресурсы
void dispose(int id);
```

## Further upgrades

- Вязкое поведение: добавь мягкие «пружинки» к соседям или XSPH-подобное сглаживание скоростей.
- Тепловая карта плотностей и от неё псевдосилы — дешёвая имитация «жидкости».
- Шейдеры для улучшенной визуализации пузырьков (освещение, прозрачность, искажения).
- Добавить хранилище в SQLite в Rust для сохранения/загрузки состояний симуляции.