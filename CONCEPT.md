## Цели

Проект симуляции движения вязкой жидкости состоящей из множества пузырьков.

Визуализация симуляции жидкости с пузырьками на Flutter с использованием Rust для просчета физики движения пузырьков.
Взаимодействие Flutter и Rust через FFI для императивных вызовов со стороны Flutter и переодическая отправка данных из Rust во Flutter через SendPort.

Количество пузырьков и их размер настраивается.
Размер экрана может меняться, симуляция должна адаптироваться к новым размерам.
Пузырьки взаимодействуют между собой, на них действует гравитация, стенки мира и передаваемые внешние импульсы (например, нажатия на экран).

Цель проекта максимально производительная логика и отображение большого количества сущностей (пузырьков) на экране с плавной анимацией.
Достоверность физики вторична, важна производительность и плавность.

При запуске симуляции мира создается отдельный тред в котором буфер положения точек (пузырьков) мутирует с заданой частотой (например 60 раз в секунду). После каждого обновления буфер отправляется во Flutter через SendPort для отрисовки.

Возможно тут будет полезна структура QuadTree или даже лучше Spatial Hash Grid для оптимизации поиска соседних пузырьков при расчете взаимодействия между ними.

Разделение на Broad phase и Narrow phase для оптимизации столкновений между пузырьками.

Столкновения со стенками: упругая/частично упругая реакция плюс лёгкое трение.

Обновление скоростей и интеграция позиций — параллельно по чанкам (rayon).

Построение сетки — параллельно: сначала считаем хэш-клетку для каждой точки, потом radix-like сортировка/бакетизация.

Разрешение коллизий — по клеткам, клетки распределяем по потокам. Для избежать гонок на одну частицу применяем либо:

- read old, write to temp, затем редукция
- cell-coloring (чередуем независимые клетки).

Сообщения в изолят Dart через Dart_PostCObject_DL как int о том что новый буфер готов.

Flutter явно pull'ит новый буфер Float32List из Rust на каждый кадр (60/120 Гц) если был получен сигнал что новый буфер готов.

Flutter выводит пузырьки на экран используя drawRawPoints с использованием Canvas.

Интерфейс должен обладать следующими методами:

```dart
// Инициализация DL API, вызывается один раз при загрузке библиотеки
void init_dl_api(void* init_data);

// Создать мир / симуляцию
// Передать SendPort для колбэков уведомления о готовности нового буфера
// Возвращает id созданного мира
int create(int sendPort);

// Получить снимок текущих позиций точек пузырьков
// Возвращает Float32List с позициями точек [x1, y1, x2, y2, ...]
Float32List snapshot(int id);

// Реконфигурировать мир
// Установить размеры мира, гравитацию, радиус и количество точек
void config(
    // Идентификатор мира
    int id,
    // Частота тиков / симуляции в герцах
    double tick_hz,
    // Количество CPU ядер для использования
    int cpu,
    // Размеры мира - ширина
    int worldWidth,
    // Размеры мира - высота
    int worldHeight,
    // Коэффициент упругости при столкновениях со стенками и между пузырьками
    double restitution,
    // Коэффициент вязкости жидкости
    double damping,
    // Гравитация по X
    int gravityX,
    // Гравитация по Y
    int gravityY,
    // Радиус пузырьков
    int radius,
    // Количество пузырьков
    int count
);

// Событие импульса/пуша: центр и сила
void impulse(
    // Идентификатор мира
    int id,
    // Координаты центра импульса - X
    double x,
    // Координаты центра импульса - Y
    double y,
    // Сила импульса
    double strength,
    // Радиус воздействия
    double radius
);

// Приостановить мир / симуляцию
// Просто перестать считать, например когда окно не в фокусе
void pause(int id);

// Возобновить физику
// Продолжить считать симуляцию
void resume(int id);

// Уничтожить мир и высвободить ресурсы
void dispose(int id);
```

## Further upgrades

- Вязкое поведение: добавь мягкие «пружинки» к соседям или XSPH-подобное сглаживание скоростей.
- Тепловая карта плотностей и от неё псевдосилы — дешёвая имитация «жидкости».
- Шейдеры для улучшенной визуализации пузырьков (освещение, прозрачность, искажения).
